#!/bin/bash
# SSH Multitool
#
# Ein Multifunktionswerkzeug für SSH und darauf aufbauende (SCP, SFTP, SSHFS, ...).
# Mit Unterstützung für Server, die mit Portknocking abgesichert sind.
#
# Die Konfigurationsdatei kann aus dem Menü heraus bearbeitet werden.
#
# Authors: Michael Koch, Sebastian Lehne
# Contact: m<DOT>koch<AT>emkay443<DOT>de
# License: GNU General Public License v3 (http://www.gnu.de/documents/gpl-3.0.en.html)


#################
# KONFIGURATION #
#################

# Name, Versionsnummer und Fenstertitel des Programms
name="SSH Multitool"
version="2016-03-10"
title="$name - Version $version"

# Folgende Variablen nur überschreiben
# wenn die Befehle nicht über die PATH-Variable erreichbar sind
command_dialog="$(which dialog 2> /dev/null)"
command_ssh="$(which ssh 2> /dev/null)"
command_scp="$(which scp 2> /dev/null)"
command_sshfs="$(which sshfs 2> /dev/null)"
command_ssh_keygen="$(which ssh-keygen 2> /dev/null)"
command_term="$(which xterm 2> /dev/null)"
command_wget="$(which wget 2> /dev/null)"
command_mktemp="$(which mktemp 2> /dev/null)"
command_nc="$(which nc 2> /dev/null)"
command_knock="$(which knock 2> /dev/null)"
command_unison="$(which unison 2> /dev/null)"
command_openvpn="$(which openvpn 2> /dev/null)"
command_screen="$(which screen 2> /dev/null)"

# Ort und Aufbau der Konfigurationsdateien
configfile_path="$HOME/.sshmultitool"
configfile_ext="cfg"
configfile_main_name="sshmultitool"
configfile_main="$configfile_path/$configfile_main_name.$configfile_ext"
configfile_template="$configfile_path/$configfile_main_name.$configfile_ext.template"
configfile_full="$configfile_main"

# Ermögliche das Script weiterhin als "home" auf zu rufen
check_enable_legacy=true


#######################################################################
# VORSICHT!                                                           #
# Das Verändern des folgenden Codes kann die Funktionalität           #
# des Programms stark negativ beeinträchtigen!                        #
#                                                                     #
# Verändern Sie den folgenden Code nur, wenn Sie wissen, was Sie tun! #
#######################################################################

##################
# HILFSVARIABLEN #
##################

TERM=linux
weiter=true
screen_name=home-$$

configfile_path_sed="$(echo $configfile_path | sed 's/\//\\\//g')"
configfile_dl_url="https://raw.githubusercontent.com/emkay443/sshmultitool/master/sshmultitool.cfg.template"

github_url="https://github.com/emkay443/sshmultitool"
github_file_url="https://raw.githubusercontent.com/emkay443/sshmultitool/master/sshmultitool"

cygwin_knock_dl_url="http://emkay443.de/private/scripts/knock.exe"

# Übergebene Parameter in Array speichern
for i in $(seq 1 $#); do
	eval param_array[$i]=\$$i
done

###################
# HILFSFUNKTIONEN #
###################

function knockknock {
	if [[ $knockd_enable ]]; then
		echo "Bitte warten, es wird eine Verbindung zum Server aufgebaut..."
		for port in "${knockd_ports[@]}"; do
			if [[ "$(which knock)" ]]; then
				eval knock "$server" "$port"
			else
				if [[ ! "$(uname)" == *CYGWIN* ]]; then
					nc "$server" "$port"
				else
					wget "$cygwin_knock_dl_url" -O "/bin/knock.exe"
					chmod +rx "/bin/knock.exe"
					eval "/bin/knock.exe" "$server" "$port"
				fi
			fi
			sleep $knockd_sleep
		done
	fi
}

function ssh_connect {
	clear
	ovpn_connect
	knockknock
	$command_ssh $sshparms $user@$server -p $sshport
	# read -n 1 any
	ovpn_disconnect
}

function scp_connect {
	weiter_scp=true
	while $weiter_scp; do
		curworkdir=$(pwd)
		$command_dialog --title "$title" --fselect $(echo "$curworkdir/") 10 70 2> $erg
		file_scp=$(cat $erg)
		if [ -z "$file_scp" ]; then
			weiter_scp=false
		elif [ ! -e "$file_scp" ]; then
			$command_dialog --title "$title" --msgbox "Die Datei existiert nicht." 0 0
		elif [ -d "$file_scp" ]; then
			$command_dialog --title "$title" --msgbox "Sie können nur Dateien, keine Ordner versenden!" 5 65
		else
			$command_dialog --title "$title" --no-cancel --inputbox "Geben Sie den Zielort der Datei auf dem Server an.\nLeer lassen, um in den Benutzerordner hochzuladen" 10 70 2> $erg
			destpath="$(cat $erg)"
			clear
			firstbyte=$(echo $file_scp | cut -b 1)
			if [ "$firstbyte" == "/" ]; then
				filepath=$file_scp
			else
				curworkdir=$(pwd)
				filepath="$curworkdir/$file_scp"
			fi
			ovpn_connect
			knockknock
			$command_scp -P $sshport "$filepath" $user@$server:"$destpath"
			weiter_scp=false
			echo "Drücken Sie eine beliebige Taste, um in das Hauptmenü zurückzukehren"
			read -n 1 any
			ovpn_disconnect
		fi
	done
}

function sftp_connect {
	if [[ ! "$(uname)" == *CYGWIN* ]]; then
		clear
		ovpn_connect
		knockknock
		$filemanager "sftp://$user@$server:$sshport"
		ovpn_disconnect
	else
		$command_dialog --title "$title" --msgbox "Unter Windows ist dies so direkt nicht möglich.\nWir empfehlen daher, \"WinSCP\" dafür zu installieren." 7 65
	fi
}

function sshfs_connect {
	if [[ ! "$(uname)" == *CYGWIN* ]]; then
		clear
		break=false
		$command_dialog --title "$title" --inputbox "Geben Sie den einzubindenden Ordner an" 10 60 "/" 2> $erg
		sshfsdir=$(cat $erg)
		if [ ! -z "$sshfsdir" ]; then
			$command_dialog --title "$title" --inputbox "Geben Sie den anzumeldenden Benutzer an" 10 60 "$user" 2> $erg
			sshfsuser=$(cat $erg)
			if [ ! -z "$sshfsuser" ]; then
				doAgain=true
				while $doAgain; do
					$command_dialog --title "$title" --no-cancel --inputbox "Geben Sie den Mountpunkt an.\nDer Ordner muss für Ihren Benutzer beschreibbar sein!" 10 60 "$HOME/sshfs_auf_$server" 2> $erg
					sshfsmnt=$(cat $erg)
					if [ ! -z "$sshfsmnt" ]; then
						if [ ! -e "$sshfsmnt" ]; then
							$command_dialog --title "$title" --yesno "Der Mountpunkt existiert nicht.\nSoll er erstellt werden?" 7 60
							answer=$?
							case $answer in
								0)
									if [ -w "$(dirname $sshfsmnt)" ]; then
										mkdir -p $sshfsmnt
									else
										echo "Sie benötigen erhöhte Schreibrechte, um den Ordner anlegen zu können."
										if [[ "$(which sudo)" ]]; then
											echo "Bitte geben Sie ihr Benutzerpasswort ein, um zu bestätigen."
											sudo mkdir -p "$sshfsmnt"
											sudo chown $USER@$GROUPS "$sshfsmnt"
										else
											echo "Bitte geben Sie ihr Rootpasswort ein, um zu bestätigen."
											su -c "mkdir -p \"$sshfsmnt\""
											su -c "chown $USER@$GROUPS \"$sshfsmnt\""
										fi
									fi
									;;
								1|255)
									$command_dialog --title "$title" --msgbox "Der Mountpunkt wurde nicht erstellt" 5 60
									break=true
									doAgain=false
									;;
							esac
						fi
						clear
						if ! $break; then
							if [ -w "$sshfsmnt" ]; then
								ovpn_connect
								knockknock
								echo "Baue Verbindung via SSHFS auf. Um zu beenden, drücken Sie CTRL-C"
								$command_sshfs "$sshfsuser@$server:$sshfsdir" "$sshfsmnt" -C -p $sshport -f
								ovpn_disconnect
								doAgain=false
							else
								$command_dialog --title "$title" --msgbox "Der Mountpunkt ist NUR mit root-Rechten schreibbar!\nGeben Sie einen Mountpunkt an, auf den Sie auch schreiben dürfen" 7 65
							fi
						fi
					else
						doAgain=false
					fi
				done
				if [ ! -z "$sshfsmnt" ] && ! $break; then
					clear
					$command_dialog --title "$title" --yesno "Soll der Mountpunkt gelöscht werden?" 5 60
					answer=$?
					case $answer in
						0)
							if [ -w "$sshfsmnt" ]; then
								rmdir "$sshfsmnt"
								$command_dialog --title "$title" --msgbox "Der Mountpunkt wurde erfolgreich gelöscht" 5 60
							else
								$command_dialog --title "$title" --msgbox "Der Mountpunkt darf nicht gelöscht werden!" 5 60
								exit 1
							fi
							;;
						1|255)
							$command_dialog --title "$title" --msgbox "Der Mountpunkt wurde nicht gelöscht" 5 60
							;;
					esac
				fi
			fi
		fi
	else
		$command_dialog --title "$title" --msgbox "Unter Windows ist dies so direkt nicht möglich.\nWir empfehlen daher, \"Swish\" dafür zu installieren." 7 65
	fi
}

function tunnel_connect {
	clear
	break=false
	$command_dialog --title "$title" --inputbox "Geben Sie die Quelladresse an" 0 0 "localhost" 2> $erg
	if [ -s "$erg" ]; then
		sourceaddr=$(cat $erg)
		$command_dialog --title "$title" --menu "Wählen Sie den Quellport aus" 0 0 0 \
			20 "FTP (Datenübertragung)" \
			21 "FTP (Anmeldung und Kontrolle)" \
			22 "SSH" \
			23 "Telnet" \
			25 "SMTP" \
			53 "DNS" \
			80 "HTTP" \
			110 "POP3" \
			113 "IRC Ident" \
			115 "SFTP" \
			118 "SQL" \
			143 "IMAP" \
			194 "IRC" \
			220 "IMAP v3" \
			443 "HTTPS" \
			445 "Samba" \
			531 "AOL Instant Messenger, IRC" \
			587 "SMTP (alternativ)" \
			631 "IPP" \
			989 "FTPS (Datenübertragung)" \
			990 "FTPS (Anmeldung und Kontrolle)" \
			992 "Telnet via TLS/SSL" \
			993 "IMAPS" \
			995 "POP3S" \
			1080 "SOCKS proxy" \
			1194 "OpenVPN" \
			2401 "CVS" \
			3074 "Xbox LIVE, Games for Windows-Live" \
			3306 "MySQL" \
			3389 "RDP" \
			3724 "World of Warcraft" \
			5190 "ICQ und AIM" \
			5500 "VNC (alternativ)" \
			5800 "VNC über HTTP" \
			5900 "VNC" \
			6112 "Battle.net" \
			8008 "HTTP Alternative" \
			8080 "HTTP Alternative" \
			8767 "TeamSpeak 2" \
			9001 "Tor" \
			9030 "Tor (alt.)" \
			9050 "Tor (alt.)" \
			9051 "Tor (alt.)" \
			9418 "git" \
			9987 "TeamSpeak 3" \
			10000 "Webmin" \
			11371 "OpenPGP Key Server" \
			20000 "Usermin" \
			25565 "MySQL, Minecraft" \
			X "Port manuell eingeben" \
			A "Alle Quellports" \
			0 "Programm beenden" 2> $erg
		sourceport=$(cat $erg)
		case "$sourceport" in
			X)
				$command_dialog --title "$title" --inputbox "Geben Sie den Quellport an" 0 0 2> $erg
				if [ -s "$erg" ]; then
					sourceport=$(cat $erg)
					$command_dialog --title "$title" --inputbox "Geben Sie den Zielport an" 0 0 2> $erg
					if [ -s "$erg" ]; then
						destport=$(cat $erg)
					else
						break=true
					fi
				else
					break=true
				fi
				;;
			A)
				$command_dialog --title "$title" --inputbox "Geben Sie den Zielport an" 0 0 2> $erg
				if [ -s "$erg" ]; then
					destport=$(cat $erg)
					ovpn_connect
					knockknock
					echo "Geben Sie 'localhost:$destport' als SOCKS-Proxy in Ihrem Browser ein."
					echo "Um zu beenden, drücken Sie CTRL-C"
					$command_ssh -C -N -L -D $destport $user@$server -p $sshport
					ovpn_disconnect
				fi
				break=true
				;;
			0|"")
				echo "Dann halt nicht..."
				break=true
				;;
			*)
				$command_dialog --title "$title" --inputbox "Geben Sie den Zielport an" 0 0 2> $erg
				if [ -s "$erg" ]; then
					destport=$(cat $erg)
				else
					break=true
				fi
				;;
		esac
		if ! $break; then
			ovpn_connect
			knockknock
			echo "Lassen Sie die Verbindung zum Server so lange bestehen, wie der Tunnel aktiv sein soll."
			echo "Um zu beenden, drücken Sie CTRL-C"
			if [ $destport -lt 1024 ]; then
				echo "Sie haben einen Port kleiner als 1024 gewählt. Das erfordert root-Rechte."
				if [[ "$(which sudo)" ]]; then
					sudo $command_ssh -C -N -L localhost:$destport:$sourceaddr:$sourceport $user@$server -p $sshport
				else
					su -c "$command_ssh -C -N -L localhost:$destport:$sourceaddr:$sourceport $user@$server -p $sshport"
				fi
			else
				$command_ssh -C -N -L localhost:$destport:$sourceaddr:$sourceport $user@$server -p $sshport
			fi
			ovpn_disconnect
		fi
	fi
}

function ssh_keygen {
	weiter_kg=true
	while $weiter_kg; do
		clear
		$command_dialog --title "$title" --no-cancel --inputbox "Geben Sie die Parameter für den Schlüsselgenerator an (optional)\nLeer lassen, wenn Sie damit nicht vertraut sind\nGeben Sie 'man' ein, wenn Sie die Man-Page sehen\noder 'exit', wenn Sie zurück ins Hauptmenü möchten" 10 70 2> $erg
		keygenparms=$(cat $erg)
		clear
		if [ "$keygenparms" = "man" ]; then
			man ssh-keygen
		elif [ "$keygenparms" = "exit" ]; then
			weiter_kg=false
		else
			$command_ssh_keygen $keygenparms
			weiter_kg=false
			echo "Beliebige Taste drücken, um zum Hauptmenü zurückzukehren"
			read -n 1 any
		fi
	done
}

function ssh_custom_connect {
	clear
	$command_dialog --title "$title" --inputbox "Geben Sie die Serveradresse an" 0 0 2> $erg
	if [ -s "$erg" ]; then
		tmpserver=$(cat $erg)
		$command_dialog --title "$title" --inputbox "Geben Sie den Benutzernamen an" 0 0 2> $erg
		if [ -s "$erg" ]; then
			tmpuser=$(cat $erg)
			$command_dialog --title "$title" --no-cancel --inputbox "Geben Sie die SSH-Parameter an" 0 0 "-X -C" 2> $erg
			tmpparms=$(cat $erg)
			$command_ssh $tmpparms $tmpuser@$tmpserver -p $sshport
		fi
	fi
}

function edit_config_file {
	clear
	# Die Konfiguration bearbeiten
	if [ ! -e "$(which $editor)" ]; then editor="/usr/bin/nano"; fi
	if [ ! -e "$(which $editor)" ]; then editor="/usr/bin/vi"; fi
	"$editor" "$configfile_full"
	# Konfigurationsdatei neu einlesen
	. "$configfile_full"
}

function edit_profiles {
	profiles_arr=($(ls $configfile_path/*.cfg | grep -v $configfile_main | grep -v "homescripts.cfg" | sed -e 's/'$configfile_path_sed'\///' | sed -e 's/.'$configfile_ext'//'))
	profiles_str="0 Hauptprofil"
	counter=1
	for profile in "${profiles_arr[@]}"; do
		profiles_str="$profiles_str $counter $profile"
		let counter++
	done
	profiles_str="$profiles_str n Neues_Profil_erstellen"
	profiles_str="$profiles_str c Aktuelles_Profil_kopieren"
	if [ ! "$configfile_full" = "$configfile_main" ]; then
		profiles_str="$profiles_str d Aktuelles_Profil_löschen"
	fi
	$command_dialog --title "$title" --menu "Profilauswahl\nAktuelles Profil: $(echo $configfile_full | sed -e 's/'$configfile_path_sed'\///' | sed -e 's/.'$configfile_ext'//' | sed -e 's/sshmultitool/Hauptprofil/')" 0 60 0 $profiles_str 2> $erg
	if [ -s "$erg" ]; then
		clear
		profile_index="$(cat $erg)"
		case "$(cat $erg)" in
			0)
				configfile_full="$configfile_main"
				. "$configfile_full"
				;;
			"n")
				weiter_np=true
				skip=false
				while $weiter_np; do
					$command_dialog --title "$title" --inputbox "Geben Sie den Namen des neuen Profils ein\nVerbotene Zeichen sind: \$, /, \\ und das Leerzeichen" 10 60 "profilNeu" 2> $erg
					profil_name=$(cat $erg)
					if [ ! -z "$profil_name" ]; then
						if [ ! -z "$(echo $profil_name | grep [' '\\/\$])" ]; then
							$command_dialog --title "$title" --msgbox "Der Name beinhaltet verbotene Zeichen.\nBitte wählen Sie einen Namen ohne /, \\, \$ und Leerzeichen" 7 70
						elif [ ! -e "$configfile_path/$profil_name.$configfile_ext" ]; then
							clear
							configfile_full="$configfile_path/$profil_name.$configfile_ext"
							cp_def_cfg
							weiter_np=false
							$command_dialog --title "$title" --msgbox "Das Profil wurde erfolgreich erzeugt." 5 60
						else
							$command_dialog --title "$title" --msgbox "Ein Profil mit diesem Namen existiert bereits!\nBitte wählen Sie einen neuen Namen für das Profil" 7 60
						fi
					else
						weiter_np=false
					fi
				done
				;;
			"d")
				if [ ! "$configfile_full" = "$configfile_main" ]; then
					clear
					$command_dialog --title "$title" --yesno "Wollen Sie das aktuelle Profil wirklich löschen?" 5 60
					answer=$?
					case $answer in
						0)
							rm "$configfile_full"
							configfile_full="$configfile_main"
							$command_dialog --title "$title" --msgbox "Das Profil wurde erfolgreich gelöscht" 5 60
							;;
						1|255)
							$command_dialog --title "$title" --msgbox "Das Profil wurde nicht gelöscht" 5 60
							;;
					esac
				else
					$command_dialog --title "$title" --msgbox "Das Hauptprofil kann nicht gelöscht werden" 5 60
				fi
				;;
			"c")
				weiter_cp=true
				while $weiter_cp; do
					$command_dialog --title "$title" --inputbox "Geben Sie den Namen des neuen Profils ein\nVerbotene Zeichen sind: \$, /, \\ und das Leerzeichen" 10 60 "profilNeu" 2> $erg
					profil_name="$(cat $erg)"
					if [ ! -z "$profil_name" ]; then
							if [ ! -z "$(echo $profil_name | grep [' '\\/\$])" ]; then
								$command_dialog --title "$title" --msgbox "Der Name beinhaltet verbotene Zeichen.\nBitte wählen Sie einen Namen ohne /, \\, \$ und Leerzeichen" 7 70
							elif [ ! -e "$configfile_path/$profil_name.$configfile_ext" ]; then
								clear
								cp "$configfile_full" "$configfile_path/$profil_name.$configfile_ext"
								configfile_full="$configfile_path/$profil_name.$configfile_ext"
								weiter_cp=false
								$command_dialog --title "$title" --msgbox "Das Profil wurde erfolgreich kopiert.\nDrücken Sie auf OK, um ins Hauptmenü zurückzugelangen" 10 60
							else
								$command_dialog --title "$title" --msgbox "Ein Profil mit diesem Namen existiert bereits!\nBitte wählen Sie einen neuen Namen für das Profil" 10 60
							fi
					else
						weiter_cp=false
					fi
				done
				;;
			*)
				let profile_index--
				counter=0
				while [ $counter -lt "${#profiles_arr[*]}" ]; do
					if [ $counter -eq $profile_index ]; then
						configfile_full="$configfile_path/${profiles_arr[$counter]}.$configfile_ext"
						. "$configfile_full"
					fi
					let counter++
				done
				;;
		esac
	fi
}

function ovpn_connect {
	if [[ -n "$ovpn_enable" ]]; then
		if $ovpn_enable; then
			toInst=""
			if [[ ! -e "$command_openvpn" ]]; then toInst="openvpn"; fi
			if [[ ! -z "$toInst" ]]; then
				echo "Folgende Pakete müssen installiert werden, damit das Programm reibungslos funktioniert:"
				echo $toInst
				echo
				echo "Sollen sie installiert werden? [J|n]"
				read answer
				case $answer in
					j|J|'')
						install_packages $toInst
						knockknock
						;;
					*)
						exit 1
						;;
				esac
			else
				if [[ "$(which sudo)" ]]; then
					sudo="sudo"
					suffix=""
				else
					sudo="su -c '"
					suffix="'"
				fi
				clear
				if [ -t 0 ]; then
					echo "Ein neues Terminal-Fenster wird jetzt geöffnet, um die OpenVPN-Verbindung herzustellen."
					echo "Wenn die Verbindung erfolgreich hergestellt wurde, wechseln Sie in dieses Fenster zurück"
					echo "und drücken Sie eine beliebige Taste, um die SSH-Verbindung herzustellen."
					echo
					echo "Haben Sie das vestanden? [J|n]"
					read answer
					case $answer in
						j|J|'')
							if [[ ! "$(which $terminal)" ]]; then
								terminal="$command_term"
							fi
							"$terminal" -e "$sudo $command_screen $command_openvpn --config \"$ovpn_configfile\" $suffix" &
							clear
							echo "Drücken Sie eine beliebige Taste, wenn die OpenVPN-Verbindung erfolgreich hergestellt wurde."
							echo "Schließen Sie das andere Terminal-Fenster, um die OpenVPN-Verbindung zu trennen."
							read -n 1 any
							;;
						*)
							# exit 0
							;;
					esac
				else
					echo "Starte eine screen-Sitzung mit openVPN."
					echo "Wenn die Verbindung erfolgreich hergestellt wurde, drücken Sie STRG-A-D,"
					echo "um die screen-Sitzung zu verlassen und die SSH-Verbindung herzustellen."
					echo
					echo "Haben Sie das vestanden? [J|n]"
					read answer
					case $answer in
						j|J|'')
							$sudo $command_screen -S "$screen_name" $command_openvpn --config "$ovpn_configfile" $suffix
							clear
							echo "Drücken Sie eine beliebige Taste, wenn die OpenVPN-Verbindung erfolgreich hergestellt wurde."
							read -n 1 any
							;;
						*)
							# exit 0
							;;
					esac
				fi
			fi
		fi
	fi
}

function ovpn_disconnect {
	if [[ -n "$ovpn_enable" ]]; then
		if $ovpn_enable; then
			if [ ! -t 0 ]; then
				if [ "$(pidof $(basename $command_openvpn))" ]; then
					clear
					echo "Soll die OpenVPN-Verbindung getrennt werden? [J|n]"
					read answer
					case $answer in
						j|J|'')
							echo "Drücken Sie im nächsten Fenster STRG-C, um die OpenVPN-Verbindung zu trennen."
							echo "Drücken Sie jetzt eine beliebige Taste, wenn Sie das verstanden haben."
							read -n 1 any
							screen -r $screen_name
							;;
						*)
							echo "Um die OpenVPN-Verbindung später zu trennen,"
							echo "geben Sie \"$command_screen -r $screen_name\" ein"
							echo "und drücken Sie dort STRG-C."
							echo "Drücken Sie jetzt eine beliebige Taste, wenn Sie das verstanden haben."
							read -n 1 any
							exit 0
							;;
					esac
				fi
			fi
		fi
	fi
}

function synchronise {
	if $sync_enable; then
		knockknock
		$command_unison $sync_params $sync_profil
		if [ $sync_wait_afterwards -lt 0 ]; then
			echo "Drücken Sie eine beliebige Taste, um ins Hauptmenü zurückzukehren"
			read -n 1 any
		else
			sleep $sync_wait_afterwards
		fi
	fi
}

function dl_def_cfg {
	mkdir -p "$configfile_path"
	echo "Für die richtige Funktionalität des Skripts muss eine Konfigurationsdatei aus dem Internet heruntergeladen werden."
	echo "Soll das für Sie getan werden? [J|n]"
	read answer
	case $answer in
	j|J|"")
		$command_wget "$configfile_dl_url" -O "$configfile_template"
		if [ -z "$(cat $configfile_template)" ]; then
			echo "FEHLER: Konnte Konfigurationsdatei nicht herunterladen!"
			echo "Bitte überprüfen Sie ihre Netzwerkverbindung und starten Sie das Programm erneut."
			exit 1
		fi
		;;
	*)
		echo "Dann halt nicht..."
		exit 2
		;;
	esac
}

function cp_def_cfg {
	echo "Soll die Konfigurationsdatei vom Musterprofil kopiert werden? [J|n]"
	read answer
	case $answer in
	j|J|"")
		cp "$configfile_template" "$configfile_full"
		"$editor" "$configfile_full"
		. "$configfile_full"
		;;
	*)
		echo "Dann halt nicht..."
		configfile_full="$configfile_main"
		;;
	esac
}

function install_packages {
	packages=$*
	if [[ "$(which sudo)" ]]; then
		sudo="sudo"
		suffix=""
	else
		sudo="su -c '"
		suffix="'"
	fi
	if [[ "$(which apt-get)" ]]; then
		# Ubuntu, Mint, Debian, Mac OS X (Fink)
		manager="apt-get install"
	elif [[ "$(which aptitude)" ]]; then
		# Ubuntu, Mint, Debian
		manager="aptitude install"
	else
		echo "Problem: Keine unterstütze Paketverwaltung gefunden."
		echo "Bitte installieren Sie folgende Pakete manuell"
		echo "und starten Sie dieses Programm dann erneut:"
		echo $packages
		if [[ "$(uname)" == *Darwin* ]]; then
			echo ""
			echo "Sie scheinen Mac OS X zu verwenden."
			echo "Daher empfehlen wir Ihnen, MacPorts (http://macports.org) zu installieren."
			echo "MacPorts ist eine Paketverwaltung mit vielen Programmen aus der Linux-Welt."
			echo "Nach der Installation von MacPorts starten Sie dieses Programm einfach neu."
		elif [[ "$(uname)" == *CYGWIN* ]]; then
			echo ""
			echo "Sie scheinen Windows (Cygwin) zu verwenden."
			echo "Daher müssen Sie die oben gezeigten Programme über den Cygwin-Installer selbst installieren."
			echo "Nachdem Sie das getan haben, starten Sie dieses Programm erneut."
		fi
		exit 1
	fi
	$sudo $manager $packages $suffix
}

function check_for_dependencies {
	if [[ ! -e "$command_ssh" ]]; then toInst=$toInst" openssh"; fi
	if [[ ! -e "$command_dialog" ]]; then toInst=$toInst" dialog"; fi
	if [[ ! -e "$command_wget" ]]; then toInst=$toInst" wget"; fi
	if [[ ! "$(uname)" == *CYGWIN* ]] && [[ ! -e "$command_sshfs" ]]; then toInst=$toInst" sshfs"; fi
	if [[ ! -e "$command_mktemp" ]]; then toInst=$toInst" mktemp"; fi
	if [[ ! "$(uname)" == *CYGWIN* ]] && [[ ! -e "$command_knock" ]]; then toInst=$toInst" knockd"; fi

	if [[ ! -z $toInst ]]; then
		echo "Folgende Pakete müssen installiert werden, damit das Programm reibungslos funktioniert:"
		echo $toInst
		echo
		echo "Sollen sie installiert werden? [J|n]"
		read answer
		case $answer in
			j|J|'')
				install_packages $toInst
				;;
			*)
				echo "Dann halt nicht. Wundern Sie sich nicht über Fehler und unnormales Verhalten."
				echo "Sollten Sie doch zur Vernunft kommen, können Sie das Programm neustarten"
				echo "und doch die Abhängigkeiten auflösen lassen. :)"
				echo "Starte trotzdem..."
				sleep 5
				;;
		esac
	fi
}

function upload_files {
	local skip_elements=0
	local number_of_files=0
	local file_indizes=( )
	local files=""

	for i in $(seq 1 $1); do
		if [ $skip_elements -gt 0 ]; then
			let skip_elements--
		elif [ "${param_array[$i]}" == "-p" ] || [ "${param_array[$i]}" == "--profil" ] || [ "${param_array[$i]}" == "--profile" ]; then
			skip_elements=1
		else
			if [ -e "${param_array[$i]}" ]; then
				let number_of_files++
				file_indizes=( "${file_indizes[@]}" "$i" )
			fi
		fi
	done

	if [ $number_of_files -gt 0 ]; then
		echo "Es wurden $number_of_files gültige Dateipfade als Parameter übergeben."
		echo "Sollen diese Dateien via SCP an den Server geschickt werden? [J|n]"
		read answer
		case $answer in
			j|J|"")
				# Konfigurationsdatei einbinden
				. "$configfile_full"
				for index in ${file_indizes[@]}; do
					firstbyte=`echo ${param_array[$index]} | cut -b 1`
					if [ "$firstbyte" == "/" ]; then
						path=${param_array[$index]}
					else
						curworkdir=`pwd`
						path="$curworkdir/${param_array[$index]}"
					fi
					path=${path// /\\\ }
					files="$files $path"
				done
				echo $files
				knockknock
				eval scp -P $sshport $files $user@$server:
				exit 0
				;;
			*)
				;;
		esac
	fi
}

function show_help {
	echo "Aufruf: $(basename $0) [OPTIONEN]   oder   $(basename $0) [DATEI[EN]]"
	echo "Ohne Parameter wird das Programm normal gestartet."
	echo "Werden gültige Dateipfade übergeben, werden die Dateien via SCP an den Server"
	echo "des aktuellen Profils (oder an den des Hauptprofils) gesendet."
	echo
	echo -e "Option\t\tlange Option\t\tBedeutung"
	echo -e "-h\t\t--help\t\t\tZeigt diese Hilfeseite an"
	echo -e "-p <PROFIL>\t--profil[e] <PROFIL>\tGibt ein Profil an und lädt ggbf. eine neue Konfigurationsdatei dafür"
	echo -e "-a [ALT] <NEU>\t--alias[ALT] <NEU>\tLegt eine symbolische Verknüpfung vom alten zum neuen Profil an"
	echo -e "-c [ALT] <NEU>\t--copy [ALT] <NEU>\tKopiert das übergebene oder das Hauptprofil zum Profil <NEU>"
	echo -e "-m <ALT> <NEU>\t--move <ALT> <NEU>\tBenennt das übergebene Profil in <NEU> um"
	echo -e "-d <PROFIL>\t--delete <PROFIL>\tLöscht das übergebene Profil"
	echo -e "-r [PROFIL]\t--reset [PROFIL]\tErsetzt das übergebene oder das Hauptprofil mit einem neuen Blankoprofil"
	echo -e "-u\t\t--update\t\tSucht beim Starten nach einer neuen Version des Skripts"
	echo -e "-ud\t\t--update-only-download\tLädt nur die aktuelle Version des Skripts herunter, ohne das Skript selbst zu updaten"
	echo -e "-k\t\t--knock\t\t\tNur anklopfen"
	echo -e "-1\t\t--ssh\t\t\tDirekt per SSH verbinden"
	echo -e "-2\t\t--scp\t\t\tDirekt Dateien per SCP hochladen"
	echo -e "-3\t\t--sftp\t\t\tDirekt per SFTP verbinden"
	echo -e "-4\t\t--sshfs\t\t\tDirekt SSHFS einbinden"
	echo -e "-5\t\t--tunnel\t\tTunneldialog aufrufen"
	echo -e "-6\t\t--keygen\t\tSchlüsselgenerator aufrufen"
	echo -e "-7\t\t--custom\t\tMit eigener SSH-Konfiguration verbinden"
	echo -e "-8\t\t--editconfigs\t\tKonfigurationsdatei bearbeiten"
	echo -e "-9\t\t--editprofiles\t\tProfileditor aufrufen"
	echo -e "-10\t\t--unison\t\tUnison-Synchronisation"
	echo -e "-v\t\t--version\t\tZeigt die Versionsnummer und eine Kurzinfo an"
}

function change_profile {
	if [ ! -z "$1" ]; then
		configfile_full="$configfile_path/$1.$configfile_ext"
		if [ ! -e "$configfile_path/$1.$configfile_ext" ]; then
			echo "Das angegebene Profil kann nicht gefunden werden."
			echo "Ein neues Profil wird erstellt."
			cp_def_cfg
		fi
		. "$configfile_full"
	fi
}

function list_profiles {
	echo "Folgende Profile sind verfügbar:"
	ls $configfile_path/*.cfg | grep -v $configfile_main | sed -e 's/'$configfile_path_sed'\///' | sed -e 's/.'$configfile_ext'//'
	echo
	echo "Nutzung:"
	echo "$(basename $0) -p PROFILNAME"
	exit 0
}

function create_profile_alias {
	if [ ! -z "$1" ] && [ ! -z "$2" ]; then
		if [ ! -e "$configfile_path/$1.$configfile_ext" ]; then
			echo "Das angegebene Profil kann nicht gefunden werden. Beende."
			exit 1
		else
			if [ -e "$configfile_path/$2.$configfile_ext" ]; then
				echo "Das Zielprofil existiert bereits! Soll es überschrieben werden? [j|N]"
				read answer
				case $answer in
					"j"|"J")
						rm "$configfile_path/$2.$configfile_ext"
						;;
					"*"|"")
						echo "Dann halt nicht. Beende."
						exit 0
						;;
				esac
			fi
			ln -s "$configfile_path/$1.$configfile_ext" "$configfile_path/$2.$configfile_ext"
			configfile_full="$configfile_path/$2.$configfile_ext"
		fi
	fi
}

function copy_profile {
	if [ ! -z "$1" ] && [ ! -z "$2" ]; then
		if [ ! -z "$(echo $1 | grep [' '\\/\$])" ] || [ ! -z "$(echo $2 | grep [' '\\/\$])" ]; then
			echo "Der Name beinhaltet verbotene Zeichen. Beende."
			exit 1
		elif [ ! -e "$configfile_path/$1.$configfile_ext" ]; then
			echo "Das angegebene Profil kann nicht gefunden werden. Beende."
			exit 1
		else
			if [ -e "$configfile_path/$2.$configfile_ext" ]; then
				echo "Das Zielprofil existiert bereits! Soll es überschrieben werden? [j|N]"
				read answer
				case $answer in
					"j"|"J")
						;;
					"*"|"")
						echo "Dann halt nicht. Beende."
						exit 0
						;;
				esac
			fi
			cp "$configfile_path/$1.$configfile_ext" "$configfile_path/$2.$configfile_ext"
			configfile_full="$configfile_path/$2.$configfile_ext"
		fi
	fi
}

function move_profile {
	if [ ! -z "$1" ] && [ ! -z "$2" ]; then
		if [ ! -z "$(echo $1 | grep [' '\\/\$])" ] || [ ! -z "$(echo $2 | grep [' '\\/\$])" ]; then
			echo "Der Name beinhaltet verbotene Zeichen. Beende."
			exit 1
		elif [ ! -e "$configfile_path/$1.$configfile_ext" ]; then
			echo "Das angegebene Profil kann nicht gefunden werden. Beende."
			exit 1
		else
			if [ -e "$configfile_path/$2.$configfile_ext" ]; then
				echo "Das Zielprofil existiert bereits! Soll es überschrieben werden? [j|N]"
				read answer
				case $answer in
					"j"|"J")
						;;
					"*"|"")
						echo "Dann halt nicht. Beende."
						exit 0
						;;
				esac
			fi
			mv "$configfile_path/$1.$configfile_ext" "$configfile_path/$2.$configfile_ext"
			configfile_full="$configfile_path/$2.$configfile_ext"
		fi
	fi
}

function delete_profile {
	if [ ! -z "$1" ]; then
		configfile_full="$configfile_path/$1.cfg"
		if [ ! -e "$configfile_full" ]; then
			echo "Das Profil existiert nicht. Breche ab."
			exit 1
		fi
		if [ ! "$configfile_full" = "$configfile_main" ]; then
			echo "Die zu löschende Konfigurationsdatei ist: $configfile_full"
			echo "Soll die Konfigurationsdatei wirklich gelöscht werden? [j|N]"
			read answer
			case $answer in
				"j"|"J")
					rm "$configfile_full"
					echo "Die Konfigurationsdatei wurde gelöscht. Beende."
					exit 0
					;;
				""|"*")
					echo "Dann halt nicht. Beende."
					exit 0
					;;
			esac
		else
			echo "Das Hauptprofil kann nicht gelöscht werden. Breche ab."
			exit 1
		fi
	fi
}

function reset_profile {
	if [ ! -z "$1" ]; then
		configfile_full="$configfile_path/$1.$configfile_ext"
	fi
	if [ ! -e "$configfile_full" ]; then
		echo "Das Profil existiert nicht. Breche ab."
		exit 1
	fi
	echo "Die zuzrückzusetzende Konfigurationsdatei ist: $configfile_full"
	echo "Soll die Konfigurationsdatei wirklich zurückgesetzt werden? [j|N]"
	read answer
	case $answer in
		"j"|"J")
			cp_def_cfg
			;;
	esac
}

function show_version_info {
	echo "Verbindungsskript für SSH und darauf aufbauende (SCP, SFTP, SSHFS, ...)"
	echo "mit Unterstützung für mit Portknocking abgesicherte Server"
	echo "und konfigurierbaren Profilen"
	echo
	echo "Version: $version"
	echo "Authors: Michael Koch, Sebastian Lehne"
	echo "Contact: m<DOT>koch<AT>emkay443<DOT>de"
	echo "License: GNU General Public License v3 (http://www.gnu.de/documents/gpl-3.0.en.html)"
	echo "Source: $github_url"
	exit 0
}

function check_for_updates {
	auto_update=true
	if [[ ! "$(which dos2unix)" ]]; then
		$command_dialog --title "DOS2UNIX" --yesno "DOS2UNIX ist nicht installiert.\nEs wird für die automatische Update-Funktion benötigt, ist aber dennoch optional.\n\nSoll es automatisch installiert werden?" 0 0
		answer=$?
		case $answer in
			0)
				install_packages " dos2unix"
				;;
			*)
				auto_update=false
				;;
		esac
	fi
	tmpfile=$(mktemp) || (echo "Fehler beim anlegen der TEMP-Datei." && exit 1)
	echo "Nach Updates wird gesucht. Bitte warten..."
	$command_wget -O "$tmpfile" "$github_file_url"
	case $? in
		0)
			if $auto_update; then
				new_version="$(grep -m 1 version= $tmpfile | sed 's/version="//' | sed 's/"//' | dos2unix)"
			else
				new_version="$(grep -m 1 version= $tmpfile | sed 's/version="//' | sed 's/"//')"
			fi
			if [[ ! "$new_version" == "$version" ]] || [[ $update_only_download ]]; then
				if [[ "$(which $0)" ]]; then
					scriptfile="$(which $0)"
				else
					scriptfile="$0"
				fi
				if [[ ! "$update_only_download" ]]; then
					if $auto_update; then
						$command_dialog --title "$title" --yesno "Eine neue Version ist verfügbar: $new_version\nSoll sie automatisch installiert werden?" 0 0
						answer=$?
						case $answer in
							0)
								if [ -w "$scriptfile" ]; then
									dos2unix -n "$tmpfile" "$scriptfile"
									chmod +rx "$scriptfile"
								else
									if [[ "$(which sudo)" ]]; then
										sudo dos2unix -n "$tmpfile" "$scriptfile"
										sudo chmod +rx "$scriptfile"
									else
										su -c "dos2unix -n \"$tmpfile\" \"$scriptfile\""
										su -c "chmod +rx \"$scriptfile\""
									fi
								fi
								$command_dialog --title "$title" --msgbox "Das Update war erfolgreich.\nStarten Sie das Skript nun neu." 0 0
								clear
								exit 0
								;;
						esac
					else
						$command_dialog --title "$title" --msgbox "Es ist ein Update verfügbar: $new_version\n\nLaden Sie und installieren Sie es manuell von folgender Seite:\n$github_file_url" 0 0
					fi
				else
					if [ -w "$scriptfile" ]; then
						dos2unix -n "$tmpfile" "$scriptfile""_1"
						chmod +rx "$scriptfile""_1"
					else
						if [[ "$(which sudo)" ]]; then
							sudo dos2unix -n "$tmpfile" "$scriptfile""_1"
							sudo chmod +rx "$scriptfile""_1"
						else
							su -c "dos2unix -n \"$tmpfile\" \"$scriptfile\"\"_1\""
							su -c "chmod +rx \"$scriptfile\"\"_1\""
						fi
					fi
					$command_dialog --title "$title" --msgbox "Die aktuellste Version des Skripts wurde heruntergeladen.\nSie befindet sich hier: $scriptfile""_1" 0 0
					clear
					exit 0
				fi
			else
				$command_dialog --title "$title" --msgbox "Es gibt kein Update, Sie verwenden bereits die aktuellste Version." 0 0
			fi
			;;
		*)
			$command_dialog --title "$title" --msgbox "Es konnte nicht nach Updates gesucht werden.\nÜberprüfen Sie Ihre Internetverbindung\nund versuchen Sie es erneut." 0 0
			exit 0
			;;
	esac
	rm $tmpfile
}

function check_for_legacy_folders {
	if [ ! -L "$HOME/.homeconnect" -a -d "$HOME/.homeconnect" ] ; then
		echo "Es scheint als hätten sie bisher eine ältere Version dieses Skripts benutzt,"
		echo "welche noch unter dem Namen \"home\" firmierte. Möchten sie den alten"
		echo "Konfigurationspfad weiter verwenden? Dies wird über einen Softlink auf den"
		echo "neuen Ordner realisiert. [j|n]"
		read legacy_path_answer

		case $legacy_path_answer in
			j|J)
				#Softlinks anlegen
				if [ -e "$configfile_path" ]; then
					mv "$HOME/.homeconnect/*" "$configfile_path"
					rmdir "$HOME/.homeconnect"
				else
					mv "$HOME/.homeconnect" "$configfile_path"
				fi
				if [ -e "$configfile_path/homescripts.cfg" ]; then
					mv "$configfile_path/homescripts.cfg" "$configfile_main"
				fi
				if [ -e "$configfile_path/homescripts.cfg.template" ]; then
					mv "$configfile_path/homescripts.cfg.template" "$configfile_template"
				fi
				ln -s "$configfile_main" "$configfile_path/homescripts.cfg"
				ln -s "$configfile_template" "$configfile_path/homescripts.cfg.template"
				ln -s "$configfile_path" "$HOME/.homeconnect"
				;;
			n|N)
				#Just move everything
				if [ -e "$configfile_path" ]; then
					mv "$HOME/.homeconnect/*" "$configfile_path"
					rmdir "$HOME/.homeconnect"
				else
					mv "$HOME/.homeconnect" "$configfile_path"
				fi
				if [ -e "$configfile_path/homescripts.cfg" ]; then
					mv "$configfile_path/homescripts.cfg" "$configfile_main"
				fi
				if [ -e "$configfile_path/homescripts.cfg.template" ]; then
					mv "$configfile_path/homescripts.cfg.template" "$configfile_template"
				fi
				;;
			*)
				#Abbort
				echo "Bitte entscheiden sie sich zwischen Ja oder Nein [j|n]."
				echo "Abbruch!"
				exit 1
				;;
		esac

	fi
}

function enable_legacy_name {
	oldprogpath="$(which home 2>/dev/null)"
	if [ ! -z $oldprogpath -a ! -L $oldprogpath ]; then
		progpath="$(which $0)"
		progdir=$(dirname "${progpath}")
		if [ -w $progdir ]; then
			sudo_dir=""
			suffix_dir=""
		else
			if [[ "$(which sudo)" ]]; then
				sudo_dir="sudo"
				suffix_dir=""
			else
				sudo_dir="su -c '"
				suffix_dir="'"
			fi
		fi

		if [ -w $progpath ]; then
			sudo_file=""
			suffix_file=""
		else
			if [[ "$(which sudo)" ]]; then
				sudo_file="sudo"
				suffix_file=""
			else
				sudo_file="su -c '"
				suffix_file="'"
			fi
		fi

		if [ -w $oldprogpath ]; then
			sudo_old=""
			suffix_old=""
		else
			if [[ "$(which sudo)" ]]; then
				sudo_old="sudo"
				suffix_old=""
			else
				sudo_old="su -c '"
				suffix_old="'"
			fi
		fi

		echo "Es scheint als hätten sie bisher eine ältere Version dieses Skripts benutzt,"
		echo "welche noch unter dem Namen \"home\" firmierte. Möchten sie den"
		echo "Legacy-Support aktivieren, welcher es ihnen ermöglicht das Skript weiterhin"
		echo "mit \"home\" auf zu rufen? Dies wird durch Softlinks auf entsprechende"
		echo "Programm-Dateien realisiert. Diese Entscheidung gilt Systemweit. [j|n]"
		read legacy_answer

		case $legacy_answer in
			j|J)
				#Softlinks anlegen
				$sudo_old rm -i "$oldprogpath" $suffix_old
				$sudo_dir ln -s "$progpath" "$progdir/home" $suffix_dir
				;;
			n|N)
				#Nothing to do
				;;
			*)
				echo "Bitte entscheiden sie sich zwischen Ja oder Nein [j|n]."
				echo "Abbruch!"
				exit 1
				;;
		esac

		$sudo_file sed -i "s/^check_enable_legacy=true/check_enable_legacy=false/" "$progpath" $suffix_file
	fi
}

function search_array {
	index=0
	while [ "$index" -lt "${#searchArray[@]}" ]; do
		if [ "${searchArray[$index]}" = "$1" ]; then
			echo $index
			return
		fi
		let "index++"
	done
	echo ""
}

#################
# HAUPTPROGRAMM #
#################

# Wenn im Terminal geöffnet...
if [ -t 0 ]; then
	# Gegebenenfalls aufruf über alten Programmnamen ermöglichen
	if [ check_enable_legacy ]; then
		enable_legacy_name
	fi

	# Nach altem Config-Ordner checken, ggbf. verschieben
	check_for_legacy_folders

	# Abhängigkeiten auflösen
	clear
	check_for_dependencies

	# Temporäre Datei erzeugen
	erg=$(mktemp) || (echo "Fehler beim anlegen der TEMP-Datei." && exit 1)

	# Standardeditor einstellen, wird später von Config überschrieben
	if [ -z "$EDITOR" ]; then
		editor="$(which nano)"
		if [ ! -e "$editor" ]; then editor="$(which vi)"; fi
	fi

	# Konfigurations-Ordner erstellen, falls nicht schon existent
	mkdir -p "$configfile_path"

	# Konfigurationsdatei ggbf. herunterladen, falls nicht vorhanden
	if [ ! -e "$configfile_template" ]; then
		dl_def_cfg
	fi

	if [ ! -e "$configfile_full" ]; then
		clear
		cp_def_cfg
	fi

	# Konfigurationsdatei einbinden
	. "$configfile_full"

	# Parameter überprüfen, falls Dateien, per SCP hochladen
	if [ $# -gt 0 ]; then
		for i in "$@"; do
			case $i in
				"-p"|"--profil"|"--profile")
					searchArray=( "$@" )
					parm_pos=$(search_array $i)
					profile_pos=$(($parm_pos+2))
					if [ ! -z "${!profile_pos}" ]; then
						change_profile "${!profile_pos}"
						upload_files $#
					else
						list_profiles
					fi
					;;
				"-a"|"--alias")
					searchArray=( "$@" )
					parm_pos=$(search_array $i)
					src_pos=$(($parm_pos+2))
					dst_pos=$(($parm_pos+3))
					if [ ! -z "${!src_pos}" ] && [ ! -z "${!dst_pos}" ]; then
						create_profile_alias "${!src_pos}" "${!dst_pos}"
					elif [ ! -z "${!src_pos}" ]; then
						create_profile_alias "$configfile_main_name" "${!src_pos}"
					else
						show_help
						exit 1
					fi
					exit 0
					;;
				"-c"|"--copy")
					searchArray=( "$@" )
					parm_pos=$(search_array $i)
					src_pos=$(($parm_pos+2))
					dst_pos=$(($parm_pos+3))
					if [ ! -z "${!src_pos}" ] && [ ! -z "${!dst_pos}" ]; then
						copy_profile "${!src_pos}" "${!dst_pos}"
					elif [ ! -z "${!src_pos}" ]; then
						copy_profile "$configfile_main_name" "${!src_pos}"
					else
						show_help
						exit 1
					fi
					exit 0
					;;
				"-m"|"--move")
					searchArray=( "$@" )
					parm_pos=$(search_array $i)
					src_pos=$(($parm_pos+2))
					dst_pos=$(($parm_pos+3))
					if [ ! -z "${!src_pos}" ] && [ ! -z "${!dst_pos}" ]; then
						move_profile "${!src_pos}" "${!dst_pos}"
					else
						show_help
						exit 1
					fi
					exit 0
					;;
				"-d"|"--delete")
					searchArray=( "$@" )
					parm_pos=$(search_array $i)
					profile_pos=$(($parm_pos+2))
					if [ ! -z "${!profile_pos}" ]; then
						delete_profile "${!profile_pos}"
					fi
					exit 0
					;;
				"-r"|"--reset")
					searchArray=( "$@" )
					parm_pos=$(search_array $i)
					profile_pos=$(($parm_pos+2))
					if [ ! -z "${!profile_pos}" ]; then
						reset_profile "${!profile_pos}"
					else
						reset_profile "$configfile_main_name"
					fi
					exit 0
					;;
				"-k"|"--knock")
					if [[ $knockd_enable ]]; then
						echo "Klopfe an..."
						knockknock
						exit 0
					else
						echo "Für das Profil ist Port-Knocking nicht aktiviert. Tue nichts."
						exit 0
					fi
					;;
				"-v"|"--version")
					show_version_info
					exit 0
					;;
				"-h"|"--help")
					show_help
					exit 0
					;;
				"-u"|"--update")
					search_for_updates=true
					;;
				"-ud"|"--update-download")
					search_for_updates=true
					update_only_download=true
					;;
				"-1"|"--ssh")
					action="ssh_connect"
					;;
				"-2"|"--scp")
					action="scp_connect"
					;;
				"-3"|"--sftp")
					action="sftp_connect"
					;;
				"-4"|"--shfs")
					action="sshfs_connect"
					;;
				"-5"|"--tunnel")
					action="tunnel_connect"
					;;
				"-6"|"--keygen")
					action="ssh_keygen"
					;;
				"-7"|"--custom")
					action="ssh_custom_connect"
					;;
				"-8"|"--editconfig")
					action="edit_config_file"
					;;
				"-9"|"--editprofiles")
					action="edit_profiles"
					;;
				"-10"|"--unison")
					clear
					synchronise
					;;
			esac
		done
	fi

	if [[ $search_for_updates ]]; then
		clear
		check_for_updates
	fi

	if [ ! -z "$action" ]; then
		$action
		exit 0
	fi

	clear

	# Endlosschleife
	while $weiter; do
		if $sync_enable; then
			$command_dialog --title "$title" --menu "Hauptmenü\nAktuelles Profil: $(echo $configfile_full | sed -e 's/'$configfile_path_sed'\///' | sed -e 's/.'$configfile_ext'//' | sed -e 's/sshmultitool/Hauptprofil/')" 0 0 0 \
			1 "SSH Verbindung zum Server aufbauen" \
			2 "Dateien via SCP an den Server senden" \
			3 "SFTP Verbindung im Dateimanager öffnen" \
			4 "SSHFS einbinden" \
			5 "SSH Tunnel aufbauen" \
			6 "SSH-Schlüsselgenerator starten" \
			7 "Mit einer anderen SSH-Konfiguration verbinden" \
			8 "Konfigurationsdatei bearbeiten" \
			9 "Profilverwaltung" \
			10 "Synchronisieren über Unison-Profil" \
			\? "Über dieses Programm" \
			0 "Programm beenden" 2> $erg
		else
			$command_dialog --title "$title" --menu "Hauptmenü\nAktuelles Profil: $(echo $configfile_full | sed -e 's/'$configfile_path_sed'\///' | sed -e 's/.'$configfile_ext'//' | sed -e 's/sshmultitool/Hauptprofil/')" 0 0 0 \
			1 "SSH Verbindung zum Server aufbauen" \
			2 "Dateien via SCP an den Server senden" \
			3 "SFTP Verbindung im Dateimanager öffnen" \
			4 "SSHFS einbinden" \
			5 "SSH Tunnel aufbauen" \
			6 "SSH-Schlüsselgenerator starten" \
			7 "Mit einer anderen SSH-Konfiguration verbinden" \
			8 "Konfigurationsdatei bearbeiten" \
			9 "Profilverwaltung" \
			\? "Über dieses Programm" \
			0 "Programm beenden" 2> $erg
		fi 2>/dev/null
		echo
		case "$(cat $erg)" in
			1)
				# SSH
				ssh_connect
				;;
			2)
				# Dateien via SCP übertragen
				scp_connect
				;;
			3)
				# SFTP
				sftp_connect
				;;
			4)
				# SSHFS
				sshfs_connect
				;;
			5)
				# SSH Tunnel
				tunnel_connect
				;;
			6)
				# SSH Schlüsselgenerator
				ssh_keygen
				;;
			7)
				# Eigene SSH Konfiguration
				ssh_custom_connect
				;;
			8)
				# Konfigurationsdatei bearbeiten
				edit_config_file
				;;
			9)
				# Profilmanagement
				edit_profiles
				;;
			10)
				# Unison Synchronisation
				clear
				synchronise
				;;
			"?")
				# Version anzeigen
				show_version_info | $command_dialog --progressbox "Über dieses Programm (Zurück: Beliebige Taste drücken)" 13 88
				read -n 1 any
				;;
			0|"")
				# Ende
				weiter=false
				;;
			esac

	done
	rm "$erg"
	clear
else
	# ... sonst in Terminal öffnen
	. "$configfile_full"
	if [[ ! "$(which $terminal)" ]]; then
		terminal="$command_term"
	fi
	"$terminal" -e "$0"
fi

exit 0
